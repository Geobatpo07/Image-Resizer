{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Systeme de Redimensionnement Haute Qualite base sur B Splines Adaptatives, Filtrage Anisotropique et Pyramides Laplaciennes\n",
        "\n",
        "Ce notebook implemente un pipeline moderne de redimensionnement d images combinant diffusion anisotrope (edge preserving), pyramides laplaciennes multi resolution et interpolation par B splines adaptatives.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 1. Introduction\n",
        "\n",
        "Le redimensionnement d image est une operation fondamentale en vision par ordinateur et en traitement d images (pretraitement pour reseaux neuronaux, zoom, edition, etc.). Pourtant, les methodes classiques comme le bilineaire ou le bicubique introduisent souvent des artefacts : flou general, halos autour des contours, crenelage ou amplification du bruit.\n",
        "\n",
        "Dans ce notebook, nous visons un rendu plus naturel et plus net lors du changement d echelle, en particulier pour l agrandissement, en combinant trois briques modernes :\n",
        "\n",
        "- **B splines adaptatives** pour une interpolation lisse mais controlee, sensible a la structure locale de l image.\n",
        "- **Filtrage anisotropique (diffusion anisotrope)** pour lisser le bruit tout en preservant les contours importants.\n",
        "- **Pyramides laplaciennes** pour manipuler et reconstruire les details a plusieurs resolutions.\n",
        "\n",
        "L objectif est de construire un pipeline modulaire, reutilisable et facile a experimenter, que vous pourrez ensuite comparer au redimensionnement bicubique standard d OpenCV.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 2. Documentation theorique (niveau avance)\n",
        "\n",
        "Cette section resume les idees mathematiques principales derriere les trois briques utilisees dans le pipeline.\n",
        "\n",
        "### 2.1 Splines et B splines\n",
        "\n",
        "Une *spline* est une fonction lisse par morceaux, generalement definie par raccordement de polynomes sur un ensemble de noeuds. En traitement d images, on utilise des splines pour effectuer des interpolations plus douces que les interpolations bilineaires ou bicubiques classiques definies au niveau des pixels.\n",
        "\n",
        "Les *B splines* (Basis splines) constituent une famille particuliere de splines definies par une base locale. Elles possedent plusieurs proprietes interessantes:\n",
        "\n",
        "- support local : chaque coefficient de controle n influence que quelques pixels voisins;\n",
        "- regularite elevee : les B splines d ordre 3 sont deux fois derivables, ce qui donne des surfaces lisses;\n",
        "- formulation matricielle efficace, bien adaptee a l implementation numerique.\n",
        "\n",
        "En 2D, une image est vue comme une surface echantillonnee sur une grille; une interpolation par B splines 2D construit une surface continue qui approxime ou interpole les valeurs sur la grille, puis on evalue cette surface aux nouvelles positions pour le redimensionnement.\n",
        "\n",
        "### 2.2 Pourquoi des B splines adaptatives\n",
        "\n",
        "Une interpolation globale par B splines avec des parametres fixes aura tendance a lisser les contours, ce qui peut donner un aspect trop doux lors d un agrandissement important. L idee des B splines adaptatives est de faire varier localement le comportement de l interpolation en fonction de la structure de l image:\n",
        "\n",
        "- dans les zones homogenes, on privilegie la lissite (fort lissage);\n",
        "- pres des contours ou des textures fines, on reduit le lissage pour eviter de detruire les details.\n",
        "\n",
        "Il existe plusieurs strategies possibles (adaptation des noeuds, des coefficients, de l ordre, etc.). Dans ce notebook, nous adoptons une approche pragmatique: nous melangeons deux interpolations B splines de nature differente (ordre faible et ordre eleve) a l aide d une carte d energie locale basee sur le gradient. La carte indique ou se trouvent les fortes variations, et sert a ponderer la contribution de chaque interpolation.\n",
        "\n",
        "### 2.3 Filtrage anisotropique et diffusion anisotrope\n",
        "\n",
        "Un filtre isotrope (par exemple un flou gaussien classique) lisse l image de la meme facon dans toutes les directions. Il reduit le bruit, mais il degrade aussi les contours et les structures fines.\n",
        "\n",
        "Un filtre *anisotrope* adapte sa force de lissage a la direction et a l amplitude du gradient local. Un modele celebre est la diffusion anisotrope de Perona Malik, qui se decrit par une equation aux derivees partielles de la forme\n",
        "\n",
        "  dI/dt = div( c(x, y, t) * grad(I) )\n",
        "\n",
        "ou I est l image, t un temps artificiel (nombre d iterations), grad(I) le gradient spatial et c un coefficient de conduction qui depend de la norme du gradient. Quand le gradient est faible (zone plate ou bruit), c est grand et la diffusion est forte; quand le gradient est fort (contours), c est petit et la diffusion est inhibee.\n",
        "\n",
        "On obtient ainsi un filtre *edge preserving* qui lisse les zones homogenes tout en preservant les contours significatifs. Numeriquement, on discretise cette equation par differences finies sur quelques voisins (nord, sud, est, ouest) et on itere le schema plusieurs fois.\n",
        "\n",
        "### 2.4 Pyramides gaussienne et laplacienne\n",
        "\n",
        "Une *pyramide gaussienne* est une representation multi resolution d une image obtenue en repetant deux operations:\n",
        "\n",
        "1. flou gaussien;\n",
        "2. sous echantillonnage (par exemple, division par deux de la taille a chaque niveau).\n",
        "\n",
        "On obtient ainsi une suite d images de plus en plus petites, qui capturent des details de plus en plus grossiers. Cette representation est utile pour l analyse a plusieurs echelles et pour les algorithmes qui operent du grossier au fin.\n",
        "\n",
        "Une *pyramide laplacienne* se construit a partir de la pyramide gaussienne en prenant, a chaque niveau, la difference entre une image gaussienne et la version re echantillonnee de l image gaussienne du niveau suivant. Chaque bande laplacienne contient essentiellement des details (hautes frequences) a une echelle donnee. Le dernier niveau est en general la plus petite image gaussienne.\n",
        "\n",
        "La difference avec la pyramide gaussienne est donc que la pyramide laplacienne decompose explicitement l image en bandes de frequences, ce qui permet de controler les details (amplification, attenuation, mixage, etc.). Elle est tres utilisee en fusion d images, en rehaussement de details et en compression.\n",
        "\n",
        "### 2.5 Combiner diffusion anisotrope, pyramides et B splines\n",
        "\n",
        "Le pipeline que nous allons coder suit la philosophie suivante:\n",
        "\n",
        "1. **Nettoyage structurel** : on applique une diffusion anisotrope pour reduire le bruit tout en preservant les contours. Cela stabilise l interpolation ulterieure.\n",
        "2. **Decomposition multi resolution** : on construit une pyramide laplacienne de l image denoisee. Chaque niveau contient des details a une echelle precise.\n",
        "3. **Reconstruction progressive** : en partant du niveau le plus grossier, on reconstruit progressivement l image en re echantillonnant et en ajoutant les bandes laplaciennes. Cette reconstruction multi echelle limite les artefacts lors d agrandissements importants.\n",
        "4. **Interpolation finale B spline adaptative** : pour atteindre exactement la taille cible, on applique une interpolation B spline sensible a l energie locale de l image, ce qui donne plus de souplesse dans les zones detaillees.\n",
        "5. **Rehaussement leger** : une petite dose de sharpening (unsharp masking) permet de recuperer de la nettete sans introduire trop d halos.\n",
        "\n",
        "Cette combinaison vise a produire un rendu a la fois naturel (pas de sur accentuation artificielle) et net (details mieux preserves que le bicubique pur).\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 3. Installation des dependances\n",
        "\n",
        "Nous utilisons les bibliotheques Python suivantes:\n",
        "\n",
        "- `numpy` pour la manipulation vectorisee des tableaux;\n",
        "- `scipy` pour l interpolation par B splines;\n",
        "- `opencv-python-headless` pour les operations de base en vision par ordinateur (lecture d image, pyramides, etc.);\n",
        "- `pillow` pour la compatibilite image si necessaire;\n",
        "- `matplotlib` pour la visualisation.\n",
        "\n",
        "La cellule suivante installe ces paquets si besoin.\n"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {},
      "execution_count": null,
      "outputs": [],
      "source": [
        "# Installation des dependances principales\n",
        "!pip install -q numpy scipy opencv-python-headless pillow matplotlib\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 4. Chargement et affichage d images\n",
        "\n",
        "Dans cette section nous definissons des fonctions utilitaires pour:\n",
        "\n",
        "- charger une image depuis le disque au format RGB et la normaliser dans l intervalle [0, 1];\n",
        "- generer une image de test synthetique si aucun fichier n est disponible;\n",
        "- afficher proprement les images avec Matplotlib.\n",
        "\n",
        "Pour garder le notebook auto suffisant, si le chemin `IMAGE_PATH` ne pointe vers aucun fichier, une image artificielle (degrade plus quelques formes geometriques) sera utilisee.\n"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {},
      "execution_count": null,
      "outputs": [],
      "source": [
        "# Imports principaux et fonctions utilitaires pour le chargement et l affichage\n",
        "\n",
        "import numpy as np\n",
        "import cv2\n",
        "from PIL import Image\n",
        "import matplotlib.pyplot as plt\n",
        "from typing import Tuple\n",
        "\n",
        "plt.rcParams['figure.figsize'] = (6, 6)\n",
        "plt.rcParams['axes.grid'] = False\n",
        "\n",
        "def load_image_cv2(path: str, as_float32: bool = True) -> np.ndarray:\n",
        "    '''\n",
        "    Charge une image en utilisant OpenCV et retourne un tableau RGB dans [0, 1].\n",
        "    '''\n",
        "    bgr = cv2.imread(path, cv2.IMREAD_COLOR)\n",
        "    if bgr is None:\n",
        "        raise FileNotFoundError(f'Impossible de charger le fichier: {path}')\n",
        "    rgb = cv2.cvtColor(bgr, cv2.COLOR_BGR2RGB)\n",
        "    if as_float32:\n",
        "        rgb = rgb.astype(np.float32) / 255.0\n",
        "    return rgb\n",
        "\n",
        "def create_test_image(size: Tuple[int, int] = (256, 256)) -> np.ndarray:\n",
        "    '''\n",
        "    Cree une image de test synthetique (degrade + formes) pour tester le pipeline.\n",
        "    '''\n",
        "    h, w = size\n",
        "    y, x = np.mgrid[0:h, 0:w]\n",
        "    base = np.stack(\n",
        "        [\n",
        "            x.astype(np.float32) / max(w - 1, 1),\n",
        "            y.astype(np.float32) / max(h - 1, 1),\n",
        "            0.5 * np.ones_like(x, dtype=np.float32),\n",
        "        ],\n",
        "        axis=-1,\n",
        "    )\n",
        "    img = base.copy()\n",
        "    cv2.circle(img, (w // 3, h // 3), min(h, w) // 6, (1.0, 0.2, 0.2), thickness=-1)\n",
        "    cv2.rectangle(img, (w // 2, h // 4), (w - 10, h // 2), (0.2, 1.0, 0.2), thickness=-1)\n",
        "    cv2.line(img, (0, h - 1), (w - 1, 0), (0.2, 0.2, 1.0), thickness=3)\n",
        "    return np.clip(img, 0.0, 1.0)\n",
        "\n",
        "def show_image(image: np.ndarray, title: str = '', figsize=(5, 5)) -> None:\n",
        "    '''\n",
        "    Affiche une image RGB ou niveau de gris dans une figure Matplotlib.\n",
        "    '''\n",
        "    plt.figure(figsize=figsize)\n",
        "    if image.ndim == 2:\n",
        "        plt.imshow(image, cmap='gray', vmin=0.0, vmax=1.0)\n",
        "    else:\n",
        "        plt.imshow(np.clip(image, 0.0, 1.0))\n",
        "    plt.title(title)\n",
        "    plt.axis('off')\n",
        "    plt.show()\n",
        "\n",
        "IMAGE_PATH = 'example.jpg'  # A adapter a votre propre image\n",
        "\n",
        "try:\n",
        "    img_rgb = load_image_cv2(IMAGE_PATH)\n",
        "    print(f'Image chargee depuis {IMAGE_PATH} avec forme {img_rgb.shape}.')\n",
        "except FileNotFoundError as exc:\n",
        "    print(exc)\n",
        "    print('Generation et utilisation d une image de test synthetique.')\n",
        "    img_rgb = create_test_image()\n",
        "\n",
        "show_image(img_rgb, title='Image d entree (RGB)')\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 5. Filtrage anisotropique (diffusion de Perona Malik)\n",
        "\n",
        "Nous implementons maintenant la diffusion anisotrope de Perona Malik. La discretisation se fait sur les quatre directions cardinales (nord, sud, est, ouest). Deux fonctions sont definies:\n",
        "\n",
        "- `anisotropic_diffusion_gray` pour une image en niveau de gris;\n",
        "- `anisotropic_diffusion_color` qui applique la diffusion uniquement sur la luminance dans l espace Lab, afin de mieux preserver les couleurs.\n",
        "\n",
        "Quelques parametres importants:\n",
        "\n",
        "- `niter` : nombre d iterations de diffusion (plus il est grand, plus l image est lissee);\n",
        "- `kappa` : seuil de conduction, controle la sensibilite aux gradients;\n",
        "- `gamma` : pas de temps; il doit rester inferieur a environ 0.25 pour la stabilite;\n",
        "- `option` : choix de la fonction de conduction (exponentielle ou rationnelle).\n",
        "\n",
        "Nous visualisons ensuite l effet de ce filtrage sur l image d entree.\n"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {},
      "execution_count": null,
      "outputs": [],
      "source": [
        "# Filtrage anisotropique (diffusion de Perona Malik)\n",
        "\n",
        "def anisotropic_diffusion_gray(\n",
        "    image: np.ndarray,\n",
        "    niter: int = 10,\n",
        "    kappa: float = 30.0,\n",
        "    gamma: float = 0.15,\n",
        "    option: int = 1,\n",
        ") -> np.ndarray:\n",
        "    '''\n",
        "    Diffusion anisotrope de Perona Malik sur une image niveau de gris.\n",
        "    - niter : nombre d iterations\n",
        "    - kappa : seuil de conduction (sensibilite aux gradients)\n",
        "    - gamma : pas de temps (doit rester <= 0.25 pour la stabilite en 2D)\n",
        "    - option : 1 (exponentielle) ou 2 (fonction 1 / (1 + (g / kappa)^2))\n",
        "    '''\n",
        "    img = image.astype(np.float32)\n",
        "    for _ in range(niter):\n",
        "        north = np.zeros_like(img)\n",
        "        south = np.zeros_like(img)\n",
        "        east = np.zeros_like(img)\n",
        "        west = np.zeros_like(img)\n",
        "\n",
        "        north[1:, :] = img[1:, :] - img[:-1, :]\n",
        "        south[:-1, :] = img[:-1, :] - img[1:, :]\n",
        "        east[:, :-1] = img[:, :-1] - img[:, 1:]\n",
        "        west[:, 1:] = img[:, 1:] - img[:, :-1]\n",
        "\n",
        "        if option == 1:\n",
        "            cN = np.exp(-(north / kappa) ** 2.0)\n",
        "            cS = np.exp(-(south / kappa) ** 2.0)\n",
        "            cE = np.exp(-(east / kappa) ** 2.0)\n",
        "            cW = np.exp(-(west / kappa) ** 2.0)\n",
        "        else:\n",
        "            cN = 1.0 / (1.0 + (north / kappa) ** 2.0)\n",
        "            cS = 1.0 / (1.0 + (south / kappa) ** 2.0)\n",
        "            cE = 1.0 / (1.0 + (east / kappa) ** 2.0)\n",
        "            cW = 1.0 / (1.0 + (west / kappa) ** 2.0)\n",
        "\n",
        "        img = img + gamma * (cN * north + cS * south + cE * east + cW * west)\n",
        "\n",
        "    return np.clip(img, 0.0, 1.0)\n",
        "\n",
        "def anisotropic_diffusion_color(\n",
        "    image_rgb: np.ndarray,\n",
        "    niter: int = 10,\n",
        "    kappa: float = 30.0,\n",
        "    gamma: float = 0.15,\n",
        "    option: int = 1,\n",
        ") -> np.ndarray:\n",
        "    '''\n",
        "    Applique la diffusion anisotrope uniquement sur la composante de luminance\n",
        "    dans l espace Lab afin de mieux preserver la couleur.\n",
        "    '''\n",
        "    img = np.clip(image_rgb.astype(np.float32), 0.0, 1.0)\n",
        "    img_8u = (img * 255.0).astype(np.uint8)\n",
        "    lab = cv2.cvtColor(img_8u, cv2.COLOR_RGB2LAB).astype(np.float32)\n",
        "    L, a, b = cv2.split(lab)\n",
        "    L_norm = L / 255.0\n",
        "\n",
        "    L_f = anisotropic_diffusion_gray(L_norm, niter=niter, kappa=kappa, gamma=gamma, option=option)\n",
        "    L_f = np.clip(L_f, 0.0, 1.0) * 255.0\n",
        "\n",
        "    lab_f = cv2.merge([L_f, a, b])\n",
        "    rgb_f = cv2.cvtColor(lab_f.astype(np.uint8), cv2.COLOR_LAB2RGB).astype(np.float32) / 255.0\n",
        "    return rgb_f\n",
        "\n",
        "# Exemple d application\n",
        "img_diffused = anisotropic_diffusion_color(img_rgb, niter=10, kappa=30.0, gamma=0.15, option=1)\n",
        "\n",
        "show_image(img_rgb, title='Image originale')\n",
        "show_image(img_diffused, title='Apres diffusion anisotrope (Perona Malik)')\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 6. Pyramide gaussienne et pyramide laplacienne\n",
        "\n",
        "Nous construisons une pyramide gaussienne a partir de l image diffusee, puis la pyramide laplacienne associee.\n",
        "\n",
        "- La pyramide gaussienne est obtenue par `pyrDown` (flou plus sous echantillonnage) a chaque niveau.\n",
        "- La pyramide laplacienne est definie comme la difference entre un niveau gaussien et la version re echantillonnee du niveau suivant.\n",
        "\n",
        "Nous verifions ensuite que la reconstruction a partir de la pyramide laplacienne retrouve correctement l image diffusee d origine. Cette etape est cruciale pour pouvoir manipuler les details a plusieurs echelles dans le pipeline complet.\n"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {},
      "execution_count": null,
      "outputs": [],
      "source": [
        "# Construction de la pyramide gaussienne et laplacienne\n",
        "\n",
        "def build_gaussian_pyramid(image: np.ndarray, levels: int = 4) -> list:\n",
        "    '''\n",
        "    Construit une pyramide gaussienne en appliquant flou et sous echantillonnage.\n",
        "    '''\n",
        "    assert levels >= 1\n",
        "    pyramid = [image.astype(np.float32)]\n",
        "    for _ in range(1, levels):\n",
        "        img = cv2.pyrDown(pyramid[-1])\n",
        "        pyramid.append(img)\n",
        "    return pyramid\n",
        "\n",
        "def build_laplacian_pyramid(gaussian_pyr: list) -> list:\n",
        "    '''\n",
        "    Construit la pyramide laplacienne a partir d une pyramide gaussienne.\n",
        "    '''\n",
        "    lap_pyr = []\n",
        "    for i in range(len(gaussian_pyr) - 1):\n",
        "        current = gaussian_pyr[i]\n",
        "        next_img = gaussian_pyr[i + 1]\n",
        "        size = (current.shape[1], current.shape[0])\n",
        "        up = cv2.pyrUp(next_img, dstsize=size)\n",
        "        lap = current - up\n",
        "        lap_pyr.append(lap)\n",
        "    lap_pyr.append(gaussian_pyr[-1])\n",
        "    return lap_pyr\n",
        "\n",
        "def reconstruct_from_laplacian(laplacian_pyr: list) -> np.ndarray:\n",
        "    '''\n",
        "    Reconstruit une image a partir d une pyramide laplacienne.\n",
        "    '''\n",
        "    current = laplacian_pyr[-1]\n",
        "    for level in range(len(laplacian_pyr) - 2, -1, -1):\n",
        "        size = (laplacian_pyr[level].shape[1], laplacian_pyr[level].shape[0])\n",
        "        up = cv2.pyrUp(current, dstsize=size)\n",
        "        current = up + laplacian_pyr[level]\n",
        "    return np.clip(current, 0.0, 1.0)\n",
        "\n",
        "gaussian_pyr = build_gaussian_pyramid(img_diffused, levels=4)\n",
        "laplacian_pyr = build_laplacian_pyramid(gaussian_pyr)\n",
        "\n",
        "# Visualisation de la pyramide gaussienne\n",
        "fig, axes = plt.subplots(1, len(gaussian_pyr), figsize=(4 * len(gaussian_pyr), 4))\n",
        "for idx, lvl in enumerate(gaussian_pyr):\n",
        "    axes[idx].imshow(np.clip(lvl, 0.0, 1.0))\n",
        "    axes[idx].set_title(f'Gauss niveau {idx}')\n",
        "    axes[idx].axis('off')\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "\n",
        "# Visualisation de la pyramide laplacienne (magnitude des details)\n",
        "fig, axes = plt.subplots(1, len(laplacian_pyr), figsize=(4 * len(laplacian_pyr), 4))\n",
        "for idx, lvl in enumerate(laplacian_pyr):\n",
        "    mag = np.abs(lvl)\n",
        "    mag = mag / (mag.max() + 1e-8)\n",
        "    axes[idx].imshow(mag if mag.ndim == 2 else np.clip(mag, 0.0, 1.0))\n",
        "    axes[idx].set_title(f'Laplacien {idx}')\n",
        "    axes[idx].axis('off')\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "\n",
        "# Verification de la reconstruction\n",
        "recon = reconstruct_from_laplacian(laplacian_pyr)\n",
        "show_image(recon, title='Reconstruction depuis la pyramide laplacienne')\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 7. Redimensionnement par B splines adaptatives\n",
        "\n",
        "Nous implementons maintenant le coeur de la partie interpolation:\n",
        "\n",
        "1. une fonction de redimensionnement B spline standard basee sur `RectBivariateSpline` de SciPy;\n",
        "2. une estimation de l energie locale a partir de la norme du gradient (filtre de Sobel);\n",
        "3. une strategie adaptative qui melange deux interpolations B splines (ordre faible et ordre eleve) selon l energie locale.\n",
        "\n",
        "L idee pratique est la suivante:\n",
        "\n",
        "- on calcule une carte d energie locale sur une version en niveau de gris de l image;\n",
        "- on redimensionne l image avec deux ordres de spline differents (par exemple 1 et 3);\n",
        "- on re echantillonne la carte d energie a la taille cible et on l utilise comme poids pour mixer les deux versions.\n",
        "\n",
        "Dans les zones ou le gradient est fort, on donne plus de poids a l interpolation d ordre eleve (plus de details); dans les zones plates, on privilegie l interpolation plus douce.\n"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {},
      "execution_count": null,
      "outputs": [],
      "source": [
        "# Redimensionnement par B splines (RectBivariateSpline) et version adaptative\n",
        "\n",
        "from scipy.interpolate import RectBivariateSpline\n",
        "\n",
        "def bspline_resize_channel(\n",
        "    channel: np.ndarray,\n",
        "    scale_x: float,\n",
        "    scale_y: float,\n",
        "    order: int = 3,\n",
        ") -> np.ndarray:\n",
        "    '''\n",
        "    Redimensionne un canal unique par interpolation B spline 2D.\n",
        "    '''\n",
        "    h, w = channel.shape\n",
        "    y = np.arange(h, dtype=np.float32)\n",
        "    x = np.arange(w, dtype=np.float32)\n",
        "\n",
        "    spline = RectBivariateSpline(y, x, channel.astype(np.float32), kx=order, ky=order, s=0.0)\n",
        "\n",
        "    new_h = max(int(round(h * scale_y)), 1)\n",
        "    new_w = max(int(round(w * scale_x)), 1)\n",
        "    y_new = np.linspace(0.0, float(h - 1), new_h)\n",
        "    x_new = np.linspace(0.0, float(w - 1), new_w)\n",
        "\n",
        "    out = spline(y_new, x_new)\n",
        "    return out.astype(np.float32)\n",
        "\n",
        "def bspline_resize(\n",
        "    image: np.ndarray,\n",
        "    scale_x: float,\n",
        "    scale_y: float,\n",
        "    order: int = 3,\n",
        ") -> np.ndarray:\n",
        "    '''\n",
        "    Redimensionnement B spline separable pour image 2D ou RGB.\n",
        "    '''\n",
        "    img = image.astype(np.float32)\n",
        "    if img.ndim == 2:\n",
        "        return np.clip(bspline_resize_channel(img, scale_x, scale_y, order=order), 0.0, 1.0)\n",
        "    channels = []\n",
        "    for c in range(img.shape[2]):\n",
        "        ch = bspline_resize_channel(img[:, :, c], scale_x, scale_y, order=order)\n",
        "        channels.append(ch)\n",
        "    out = np.stack(channels, axis=-1)\n",
        "    return np.clip(out, 0.0, 1.0)\n",
        "\n",
        "def compute_local_energy(gray: np.ndarray) -> np.ndarray:\n",
        "    '''\n",
        "    Calcule une carte d energie locale basee sur la norme du gradient (Sobel).\n",
        "    '''\n",
        "    g = gray.astype(np.float32)\n",
        "    gx = cv2.Sobel(g, cv2.CV_32F, 1, 0, ksize=3)\n",
        "    gy = cv2.Sobel(g, cv2.CV_32F, 0, 1, ksize=3)\n",
        "    energy = np.sqrt(gx * gx + gy * gy)\n",
        "    energy = energy / (energy.max() + 1e-8)\n",
        "    return energy\n",
        "\n",
        "def bspline_resize_adaptive(\n",
        "    image: np.ndarray,\n",
        "    scale_x: float,\n",
        "    scale_y: float,\n",
        "    order_low: int = 1,\n",
        "    order_high: int = 3,\n",
        "    beta: float = 2.0,\n",
        ") -> np.ndarray:\n",
        "    '''\n",
        "    Redimensionnement B spline adaptatif.\n",
        "    On melange une interpolation plus lisse (ordre eleve) et une interpolation\n",
        "    plus prudente (ordre faible) en fonction de l energie locale des gradients.\n",
        "    '''\n",
        "    img = np.clip(image.astype(np.float32), 0.0, 1.0)\n",
        "    if img.ndim == 2:\n",
        "        img_rgb = np.stack([img, img, img], axis=-1)\n",
        "    else:\n",
        "        img_rgb = img\n",
        "\n",
        "    gray = cv2.cvtColor((img_rgb * 255.0).astype(np.uint8), cv2.COLOR_RGB2GRAY).astype(np.float32) / 255.0\n",
        "    energy = compute_local_energy(gray)\n",
        "\n",
        "    base_low = bspline_resize(img_rgb, scale_x, scale_y, order=order_low)\n",
        "    base_high = bspline_resize(img_rgb, scale_x, scale_y, order=order_high)\n",
        "\n",
        "    out_h, out_w = base_low.shape[:2]\n",
        "    energy_resized = cv2.resize(energy, (out_w, out_h), interpolation=cv2.INTER_CUBIC)\n",
        "    e = energy_resized\n",
        "    e = e / (e.max() + 1e-8)\n",
        "\n",
        "    weights = e ** beta\n",
        "    if base_low.ndim == 3:\n",
        "        weights = weights[..., np.newaxis]\n",
        "\n",
        "    result = weights * base_high + (1.0 - weights) * base_low\n",
        "    return np.clip(result, 0.0, 1.0)\n",
        "\n",
        "# Exemple de redimensionnement B spline vs B spline adaptative\n",
        "scale_demo = 2.0\n",
        "bspline_cubic = bspline_resize(img_diffused, scale_demo, scale_demo, order=3)\n",
        "bspline_adapt = bspline_resize_adaptive(img_diffused, scale_demo, scale_demo, order_low=1, order_high=3, beta=2.0)\n",
        "\n",
        "show_image(bspline_cubic, title='Redimensionnement B spline cubique (x2)')\n",
        "show_image(bspline_adapt, title='Redimensionnement B spline adaptatif (x2)')\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 8. Pipeline moderne complet `resize_modern`\n",
        "\n",
        "Nous pouvons maintenant combiner toutes les briques precedentes dans une seule fonction de haut niveau:\n",
        "\n",
        "```python\n",
        "resize_modern(image, scale_x, scale_y, spline_order=3, diffusion_iter=10, pyr_levels=4)\n",
        "```\n",
        "\n",
        "Le pipeline suit les etapes suivantes:\n",
        "\n",
        "1. **Filtrage anisotropique** de l image d entree pour attenuer le bruit et les petits details incoherents.\n",
        "2. **Construction de la pyramide laplacienne** sur l image denoisee.\n",
        "3. **Reconstruction progressive** de la pyramide (du plus grossier au plus fin) en utilisant une interpolation B spline a chaque niveau et en option amplifiant legerement les bandes de details.\n",
        "4. **Redimensionnement final** vers la taille cible par B splines adaptatives, sensibles a l energie locale.\n",
        "5. **Sharpening optionnel** par unsharp masking leger.\n",
        "\n",
        "Cette fonction est concue pour etre modulaire: il est facile de changer le nombre de niveaux, l ordre des splines, ou les parametres de diffusion pour explorer differents compromis entre nettete et absence d artefacts.\n"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {},
      "execution_count": null,
      "outputs": [],
      "source": [
        "# Pipeline moderne complet de redimensionnement\n",
        "\n",
        "def resize_modern(\n",
        "    image: np.ndarray,\n",
        "    scale_x: float,\n",
        "    scale_y: float,\n",
        "    spline_order: int = 3,\n",
        "    diffusion_iter: int = 10,\n",
        "    pyr_levels: int = 4,\n",
        "    kappa: float = 30.0,\n",
        "    gamma: float = 0.15,\n",
        "    option: int = 1,\n",
        "    detail_boost: float = 1.0,\n",
        "    sharpen: bool = True,\n",
        ") -> np.ndarray:\n",
        "    '''\n",
        "    Pipeline de redimensionnement haute qualite combinant:\n",
        "      1) diffusion anisotrope (Perona Malik) pour denoiser en preservant les contours,\n",
        "      2) pyramide laplacienne multi resolution pour controler les details,\n",
        "      3) interpolation finale par B splines adaptatives.\n",
        "\n",
        "    Parametres\n",
        "    ----------\n",
        "    image : np.ndarray\n",
        "        Image RGB d entree dans [0, 1].\n",
        "    scale_x, scale_y : float\n",
        "        Facteurs d echelle horizontal et vertical.\n",
        "    spline_order : int\n",
        "        Ordre des B splines (3 pour cubique).\n",
        "    diffusion_iter : int\n",
        "        Nombre d iterations de diffusion anisotrope.\n",
        "    pyr_levels : int\n",
        "        Nombre de niveaux dans la pyramide laplacienne.\n",
        "    kappa, gamma, option : float, float, int\n",
        "        Parametres du modele de Perona Malik.\n",
        "    detail_boost : float\n",
        "        Gain applique aux bandes laplaciennes lors de la reconstruction.\n",
        "    sharpen : bool\n",
        "        Active un leger rehaussement de la nettete a la fin.\n",
        "    '''\n",
        "    img = np.clip(image.astype(np.float32), 0.0, 1.0)\n",
        "\n",
        "    # 1. Filtrage anisotropique pour reduire le bruit mais garder les contours\n",
        "    denoised = anisotropic_diffusion_color(\n",
        "        img,\n",
        "        niter=diffusion_iter,\n",
        "        kappa=kappa,\n",
        "        gamma=gamma,\n",
        "        option=option,\n",
        "    )\n",
        "\n",
        "    # 2. Construction de la pyramide laplacienne\n",
        "    gaussian_pyr = build_gaussian_pyramid(denoised, levels=pyr_levels)\n",
        "    laplacian_pyr = build_laplacian_pyramid(gaussian_pyr)\n",
        "\n",
        "    # 3. Reconstruction progressive multi resolution jusqu a la taille d origine\n",
        "    current = laplacian_pyr[-1]\n",
        "    for level in range(len(laplacian_pyr) - 2, -1, -1):\n",
        "        target_h, target_w = laplacian_pyr[level].shape[:2]\n",
        "        scale_x_level = float(target_w) / float(current.shape[1])\n",
        "        scale_y_level = float(target_h) / float(current.shape[0])\n",
        "\n",
        "        current = bspline_resize(current, scale_x_level, scale_y_level, order=spline_order)\n",
        "        current = current + detail_boost * laplacian_pyr[level]\n",
        "        current = np.clip(current, 0.0, 1.0)\n",
        "\n",
        "    reconstructed = current\n",
        "\n",
        "    # 4. Redimensionnement final par B splines adaptatives vers la taille cible\n",
        "    resized = bspline_resize_adaptive(\n",
        "        reconstructed,\n",
        "        scale_x=scale_x,\n",
        "        scale_y=scale_y,\n",
        "        order_low=1,\n",
        "        order_high=spline_order,\n",
        "        beta=2.0,\n",
        "    )\n",
        "\n",
        "    # 5. Rehaussement leger de la nettete (unsharp masking)\n",
        "    if sharpen:\n",
        "        resized_8u = (np.clip(resized, 0.0, 1.0) * 255.0).astype(np.uint8)\n",
        "        blurred = cv2.GaussianBlur(resized_8u, (0, 0), sigmaX=1.0, sigmaY=1.0)\n",
        "        sharpened = cv2.addWeighted(resized_8u, 1.0 + 0.3, blurred, -0.3, 0)\n",
        "        resized = sharpened.astype(np.float32) / 255.0\n",
        "\n",
        "    return np.clip(resized, 0.0, 1.0)\n",
        "\n",
        "# Test rapide du pipeline sur un facteur x2\n",
        "scale_test = 2.0\n",
        "h, w = img_rgb.shape[:2]\n",
        "target_w = int(round(w * scale_test))\n",
        "target_h = int(round(h * scale_test))\n",
        "\n",
        "modern_resized = resize_modern(\n",
        "    img_rgb,\n",
        "    scale_x=scale_test,\n",
        "    scale_y=scale_test,\n",
        "    spline_order=3,\n",
        "    diffusion_iter=10,\n",
        "    pyr_levels=4,\n",
        ")\n",
        "\n",
        "show_image(modern_resized, title='Resultat du pipeline moderne (x2)')\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 9. Comparaison bicubique vs pipeline moderne\n",
        "\n",
        "Dans cette section, nous comparons visuellement le resultat du pipeline `resize_modern` avec le redimensionnement bicubique standard propose par OpenCV. Nous utilisons un facteur d echelle x2 et affichons les images dans une grille 2 x 2:\n",
        "\n",
        "- en haut a gauche: image originale;\n",
        "- en haut a droite: redimensionnement bicubique;\n",
        "- en bas a gauche: pipeline moderne;\n",
        "- en bas a droite: carte de differences normalisees entre bicubique et pipeline moderne.\n",
        "\n",
        "Cette comparaison permet de mettre en evidence les differences de rendu, en particulier sur les contours et les textures fines.\n"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {},
      "execution_count": null,
      "outputs": [],
      "source": [
        "# Comparaison bicubique OpenCV vs pipeline moderne\n",
        "\n",
        "scale_compare = 2.0\n",
        "h, w = img_rgb.shape[:2]\n",
        "target_w = int(round(w * scale_compare))\n",
        "target_h = int(round(h * scale_compare))\n",
        "\n",
        "bicubic = cv2.resize(\n",
        "    img_rgb,\n",
        "    (target_w, target_h),\n",
        "    interpolation=cv2.INTER_CUBIC,\n",
        ")\n",
        "\n",
        "modern = resize_modern(\n",
        "    img_rgb,\n",
        "    scale_x=scale_compare,\n",
        "    scale_y=scale_compare,\n",
        "    spline_order=3,\n",
        "    diffusion_iter=10,\n",
        "    pyr_levels=4,\n",
        ")\n",
        "\n",
        "fig, axes = plt.subplots(2, 2, figsize=(12, 12))\n",
        "\n",
        "axes[0, 0].imshow(np.clip(img_rgb, 0.0, 1.0))\n",
        "axes[0, 0].set_title('Original')\n",
        "axes[0, 0].axis('off')\n",
        "\n",
        "axes[0, 1].imshow(np.clip(bicubic, 0.0, 1.0))\n",
        "axes[0, 1].set_title('Bicubique OpenCV (x2)')\n",
        "axes[0, 1].axis('off')\n",
        "\n",
        "axes[1, 0].imshow(np.clip(modern, 0.0, 1.0))\n",
        "axes[1, 0].set_title('Pipeline moderne (x2)')\n",
        "axes[1, 0].axis('off')\n",
        "\n",
        "diff = np.abs(modern - bicubic)\n",
        "diff = diff / (diff.max() + 1e-8)\n",
        "axes[1, 1].imshow(np.clip(diff, 0.0, 1.0))\n",
        "axes[1, 1].set_title('Differences normalisees')\n",
        "axes[1, 1].axis('off')\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 10. Tests avec differents facteurs d echelle\n",
        "\n",
        "Pour evaluer la stabilite du pipeline, nous testons plusieurs facteurs d agrandissement:\n",
        "\n",
        "- x1.5 (zoom modere);\n",
        "- x2 (zoom classique);\n",
        "- x4 (zoom fort).\n",
        "\n",
        "Pour chaque facteur, nous affichons cote a cote:\n",
        "\n",
        "- l image originale;\n",
        "- le redimensionnement bicubique;\n",
        "- le resultat du pipeline moderne.\n",
        "\n",
        "Cela permet d observer comment la methode se comporte lorsque l on augmente fortement la frequence spatiale demandee au schema d interpolation.\n"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {},
      "execution_count": null,
      "outputs": [],
      "source": [
        "# Tests avec differents facteurs d echelle\n",
        "\n",
        "scale_factors = [1.5, 2.0, 4.0]\n",
        "\n",
        "for scale in scale_factors:\n",
        "    h, w = img_rgb.shape[:2]\n",
        "    target_w = int(round(w * scale))\n",
        "    target_h = int(round(h * scale))\n",
        "\n",
        "    bicubic = cv2.resize(\n",
        "        img_rgb,\n",
        "        (target_w, target_h),\n",
        "        interpolation=cv2.INTER_CUBIC,\n",
        "    )\n",
        "\n",
        "    modern = resize_modern(\n",
        "        img_rgb,\n",
        "        scale_x=scale,\n",
        "        scale_y=scale,\n",
        "        spline_order=3,\n",
        "        diffusion_iter=8,\n",
        "        pyr_levels=4,\n",
        "    )\n",
        "\n",
        "    fig, axes = plt.subplots(1, 3, figsize=(14, 4))\n",
        "    axes[0].imshow(np.clip(img_rgb, 0.0, 1.0))\n",
        "    axes[0].set_title('Original')\n",
        "    axes[0].axis('off')\n",
        "\n",
        "    axes[1].imshow(np.clip(bicubic, 0.0, 1.0))\n",
        "    axes[1].set_title(f'Bicubique (x{scale})')\n",
        "    axes[1].axis('off')\n",
        "\n",
        "    axes[2].imshow(np.clip(modern, 0.0, 1.0))\n",
        "    axes[2].set_title(f'Pipeline moderne (x{scale})')\n",
        "    axes[2].axis('off')\n",
        "\n",
        "    plt.suptitle(f'Comparaison de redimensionnement x{scale}')\n",
        "    plt.tight_layout()\n",
        "    plt.show()\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 11. Conclusion et pistes d amelioration\n",
        "\n",
        "Dans ce notebook, nous avons construit un pipeline de redimensionnement haute qualite qui combine:\n",
        "\n",
        "- diffusion anisotrope pour la reduction de bruit avec preservation des contours;\n",
        "- pyramides laplaciennes pour manipuler les details a plusieurs echelles;\n",
        "- B splines adaptatives pour une interpolation plus fine dans les zones riches en details.\n",
        "\n",
        "Par rapport a un simple bicubique, cette approche permet en general:\n",
        "\n",
        "- un meilleur compromis entre nettete et absence d artefacts;\n",
        "- une meilleure preservation des contours et des structures fines;\n",
        "- un controle explicite de la contribution des details par niveau de resolution.\n",
        "\n",
        "### Pistes d amelioration\n",
        "\n",
        "Ce pipeline peut servir de base a de nombreuses extensions modernes:\n",
        "\n",
        "- **Modeles de super resolution basee sur des reseaux de neurones** (CNN ou transformers) : le resultat de ce pipeline peut etre utilise comme pretraitement ou comme branche classique a combiner avec une branche apprentissage profond.\n",
        "- **Splines a base radiale** (RBF) : pour certaines applications, des bases radiales peuvent mieux capturer des distorsions non uniformes ou des geometries complexes.\n",
        "- **Guided filtering ou filtre bilateral** : ces filtres edge preserving peuvent remplacer ou completer la diffusion anisotrope, parfois avec un meilleur controle local et des proprietes numeriques differentes.\n",
        "- **Adaptation automatique des parametres** : par exemple, choisir automatiquement `diffusion_iter`, `kappa` ou le nombre de niveaux de la pyramide en fonction du contenu de l image.\n",
        "\n",
        "Vous pouvez egalement integrer ce pipeline dans une chaine de traitement plus large (super resolution hybride, compression, ou pretraitement pour des modeles de segmentation ou de detection) afin de beneficier d un redimensionnement plus robuste et plus fidele visuellement.\n"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 12. Traitement par fichier ou dossier (batch)\n",
        "\n",
        "Cette section ajoute la possibilité de lancer le pipeline sur un unique fichier image OU sur tout un dossier d'images.\n",
        "\n",
        "- Définissez `INPUT_PATH` comme chemin vers un fichier image ou un dossier.\n",
        "- Les résultats sont écrits dans `OUTPUT_DIR`.\n",
        "- Les facteurs d'échelle sont contrôlés par `SCALE_X` et `SCALE_Y`.\n",
        "- Si `KEEP_STRUCTURE=True`, la structure des sous-dossiers est préservée sous `OUTPUT_DIR`.\n",
        "- Les images sont lues/écrites via OpenCV (formats usuels: jpg, jpeg, png, bmp, tif, tiff, webp).\n"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {},
      "execution_count": null,
      "outputs": [],
      "source": [
        "# Paramètres d'entrée/sortie pour le mode fichier ou dossier\n",
        "from pathlib import Path\n",
        "import os, time\n",
        "\n",
        "INPUT_PATH = ''  # Exemple: 'data/image.jpg' ou 'data/images_folder'\n",
        "OUTPUT_DIR = 'resized_output'\n",
        "SCALE_X = 2.0\n",
        "SCALE_Y = 2.0\n",
        "KEEP_STRUCTURE = True   # conserve l'arborescence des sous-dossiers\n",
        "OVERWRITE = False       # écrase les fichiers de sortie existants si True\n",
        "VISUALIZE_SAMPLE = False  # affiche un avant/après pour quelques fichiers\n",
        "\n",
        "SUPPORTED_EXTS = {'.jpg', '.jpeg', '.png', '.bmp', '.tif', '.tiff', '.webp'}\n",
        "\n",
        "def ensure_dir(p: Path) -> None:\n",
        "    p.mkdir(parents=True, exist_ok=True)\n",
        "\n",
        "def save_image(path: Path, image: np.ndarray) -> None:\n",
        "    img_u8 = (np.clip(image, 0.0, 1.0) * 255.0).astype(np.uint8)\n",
        "    ensure_dir(path.parent)\n",
        "    ok = cv2.imwrite(str(path), cv2.cvtColor(img_u8, cv2.COLOR_RGB2BGR) if img_u8.ndim==3 else img_u8)\n",
        "    if not ok:\n",
        "        raise IOError(f\"Echec d'écriture: {path}\")\n",
        "\n",
        "def is_image_file(p: Path) -> bool:\n",
        "    return p.is_file() and (p.suffix.lower() in SUPPORTED_EXTS)\n",
        "\n",
        "def discover_images(root: Path) -> list:\n",
        "    images = []\n",
        "    for ext in SUPPORTED_EXTS:\n",
        "        images.extend(root.rglob(f'*{ext}'))\n",
        "        images.extend(root.rglob(f'*{ext.upper()}'))\n",
        "    # Supprime doublons tout en conservant l'ordre\n",
        "    seen = set()\n",
        "    uniq = []\n",
        "    for p in images:\n",
        "        if p not in seen:\n",
        "            uniq.append(p)\n",
        "            seen.add(p)\n",
        "    return uniq\n",
        "\n",
        "def make_output_path(inp: Path, input_root: Path, output_dir: Path, keep_structure: bool) -> Path:\n",
        "    # Construit le chemin de sortie: même nom + suffixe '_resized' avant l'extension\n",
        "    stem = inp.stem + '_resized'\n",
        "    out_name = stem + inp.suffix.lower()\n",
        "    if keep_structure:\n",
        "        rel = inp.parent.relative_to(input_root) if inp.parent.is_relative_to(input_root) else Path('.')\n",
        "        return output_dir / rel / out_name\n",
        "    else:\n",
        "        return output_dir / out_name\n",
        "\n",
        "def process_one_image(input_image_path: Path, scale_x: float, scale_y: float) -> np.ndarray:\n",
        "    img = load_image_cv2(str(input_image_path), as_float32=True)\n",
        "    out = resize_modern(img, scale_x=scale_x, scale_y=scale_y, spline_order=3, diffusion_iter=10, pyr_levels=4)\n",
        "    return out\n",
        "\n",
        "def run_pipeline_on_path(input_path: str, output_dir: str, scale_x: float, scale_y: float, keep_structure: bool=True, overwrite: bool=False, visualize_sample: bool=False):\n",
        "    if not input_path:\n",
        "        print('INPUT_PATH est vide. Renseignez un fichier ou un dossier et relancez cette cellule.')\n",
        "        return\n",
        "    inp = Path(input_path)\n",
        "    out_dir = Path(output_dir)\n",
        "    ensure_dir(out_dir)\n",
        "\n",
        "    files = []\n",
        "    if inp.is_file():\n",
        "        if is_image_file(inp):\n",
        "            files = [inp]\n",
        "        else:\n",
        "            print(f\"Le fichier n'est pas une image supportée: {inp}\")\n",
        "            return\n",
        "    elif inp.is_dir():\n",
        "        files = discover_images(inp)\n",
        "        if not files:\n",
        "            print(f'Aucune image trouvée dans: {inp}')\n",
        "            return\n",
        "    else:\n",
        "        print(f'Chemin introuvable: {inp}')\n",
        "        return\n",
        "\n",
        "    t0 = time.time()\n",
        "    ok_count = 0\n",
        "    fail = []\n",
        "    sample_shown = 0\n",
        "    input_root = inp if inp.is_dir() else inp.parent\n",
        "\n",
        "    for f in files:\n",
        "        try:\n",
        "            out_path = make_output_path(f, input_root, out_dir, keep_structure)\n",
        "            if out_path.exists() and not overwrite:\n",
        "                print(f'Déjà présent, on saute (OVERWRITE=False): {out_path}')\n",
        "                ok_count += 1\n",
        "                continue\n",
        "            img_out = process_one_image(f, scale_x=scale_x, scale_y=scale_y)\n",
        "            save_image(out_path, img_out)\n",
        "            ok_count += 1\n",
        "            if visualize_sample and sample_shown < 3:\n",
        "                src = load_image_cv2(str(f))\n",
        "                show_image(src, title=f'Original: {f.name}')\n",
        "                show_image(img_out, title=f'Resized: {out_path.name}')\n",
        "                sample_shown += 1\n",
        "        except Exception as e:\n",
        "            fail.append((str(f), str(e)))\n",
        "            print(f'[ERREUR] {f}: {e}')\n",
        "\n",
        "    dt = time.time() - t0\n",
        "    print(f'Terminé. {ok_count}/{len(files)} réussites en {dt:.2f}s. Sortie: {out_dir}')\n",
        "    if fail:\n",
        "        print('Echecs:')\n",
        "        for name, msg in fail:\n",
        "            print(' -', name, '->', msg)\n",
        "\n",
        "# Lance le traitement si un chemin est fourni\n",
        "run_pipeline_on_path(INPUT_PATH, OUTPUT_DIR, SCALE_X, SCALE_Y, keep_structure=KEEP_STRUCTURE, overwrite=OVERWRITE, visualize_sample=VISUALIZE_SAMPLE)\n"
      ]
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "name": "python",
      "version": "3.10",
      "mimetype": "text/x-python",
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "file_extension": ".py"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}
